local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local Camera = workspace.CurrentCamera

local DrawingUI = Instance.new("ScreenGui")
DrawingUI.Name = "Drawing"
DrawingUI.IgnoreGuiInset = true
DrawingUI.DisplayOrder = 0x7fffffff
DrawingUI.Parent = CoreGui

local renderQueue = {}

RunService.RenderStepped:Connect(function()
	for obj in renderQueue do
		if obj._dirty then
			obj:_update()
			obj._dirty = false
		end
	end
end)

local Fonts = {
	[0] = Font.fromEnum(Enum.Font.Roboto),
	[1] = Font.fromEnum(Enum.Font.Legacy),
	[2] = Font.fromEnum(Enum.Font.SourceSans),
	[3] = Font.fromEnum(Enum.Font.RobotoMono),
}

local function t(v)
	return math.clamp(1 - v, 0, 1)
end

local Drawing = {}
Drawing.Fonts = {
	UI = 0,
	System = 1,
	Plex = 2,
	Monospace = 3
}

-- Base line for Line / Triangle / Quad
local function newLine()
	local frame = Instance.new("Frame")
	frame.AnchorPoint = Vector2.new(.5,.5)
	frame.BorderSizePixel = 0
	frame.Parent = DrawingUI

	local obj = {
		From = Vector2.zero,
		To = Vector2.zero,
		Thickness = 1,
		Color = Color3.new(),
		Transparency = 1,
		Visible = true,
		ZIndex = 0,
		_dirty = true
	}

	function obj:_update()
		local dx = self.To.X - self.From.X
		local dy = self.To.Y - self.From.Y
		local dist = math.sqrt(dx*dx + dy*dy)
		frame.Size = UDim2.fromOffset(dist, self.Thickness)
		frame.Position = UDim2.fromOffset((self.From.X + self.To.X)*0.5, (self.From.Y + self.To.Y)*0.5)
		frame.Rotation = math.deg(math.atan2(dy, dx))
	end

	renderQueue[obj] = true

	return setmetatable({}, {
		__index = function(_, k)
			if k == "Remove" or k == "Destroy" then
				return function()
					renderQueue[obj] = nil
					frame:Destroy()
				end
			end
			return obj[k]
		end,
		__newindex = function(_, k, v)
			if obj[k] ~= nil and obj[k] ~= v then
				obj[k] = v
				obj._dirty = true
				if k == "Color" then frame.BackgroundColor3 = v end
				if k == "Transparency" then frame.BackgroundTransparency = t(v) end
				if k == "Visible" then frame.Visible = v end
				if k == "ZIndex" then frame.ZIndex = v end
			end
		end,
		__tostring = function() return "Drawing" end
	})
end

-- Text
local function newText()
	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.AnchorPoint = Vector2.new(.5,.5)
	label.Parent = DrawingUI

	local stroke = Instance.new("UIStroke", label)
	stroke.Enabled = false
	stroke.Thickness = 1
	stroke.Color = Color3.new()

	local obj = {
		Text = "",
		Size = 13,
		Font = 0,
		Position = Vector2.zero,
		Color = Color3.new(),
		Transparency = 1,
		Center = false,
		Outline = false,
		OutlineColor = Color3.new(),
		Visible = true,
		ZIndex = 0,
		_dirty = true
	}

	function obj:_update()
		local b = label.TextBounds
		label.Size = UDim2.fromOffset(b.X, b.Y)
		if self.Center then
			label.Position = UDim2.fromOffset(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
		else
			label.Position = UDim2.fromOffset(self.Position.X + b.X/2, self.Position.Y + b.Y/2)
		end
	end

	renderQueue[obj] = true

	return setmetatable({}, {
		__index = function(_, k)
			if k == "Remove" or k == "Destroy" then
				return function()
					renderQueue[obj] = nil
					label:Destroy()
				end
			end
			if k == "TextBounds" then return label.TextBounds end
			if k == "Object" then return label end
			return obj[k]
		end,
		__newindex = function(_, k, v)
			if obj[k] ~= nil and obj[k] ~= v then
				obj[k] = v
				obj._dirty = true
				if k == "Text" then label.Text = v end
				if k == "Size" then label.TextSize = v end
				if k == "Font" then label.FontFace = Fonts[v] end
				if k == "Color" then label.TextColor3 = v end
				if k == "Transparency" then label.TextTransparency = t(v); stroke.Transparency = t(v) end
				if k == "Visible" then label.Visible = v end
				if k == "ZIndex" then label.ZIndex = v end
				if k == "Outline" then stroke.Enabled = v end
				if k == "OutlineColor" then stroke.Color = v end
			end
		end
	})
end

-- Circle
local function newCircle()
	local frame = Instance.new("Frame")
	frame.AnchorPoint = Vector2.new(.5,.5)
	frame.BorderSizePixel = 0
	frame.Parent = DrawingUI
	local corner = Instance.new("UICorner", frame)
	corner.CornerRadius = UDim.new(1,0)
	local stroke = Instance.new("UIStroke", frame)
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

	local obj = {
		Radius = 100,
		Position = Vector2.zero,
		Thickness = 1,
		Filled = false,
		Color = Color3.new(),
		Transparency = 1,
		Visible = true,
		ZIndex = 0,
		_dirty = true
	}

	function obj:_update()
		local d = self.Radius*2
		frame.Size = UDim2.fromOffset(d,d)
		frame.Position = UDim2.fromOffset(self.Position.X, self.Position.Y)
	end

	renderQueue[obj] = true

	return setmetatable({}, {
		__index = function(_, k)
			if k == "Remove" or k == "Destroy" then
				return function() renderQueue[obj] = nil; frame:Destroy() end
			end
			if k == "CircleFrame" then return frame end
			if k == "Outline" then return stroke end
			return obj[k]
		end,
		__newindex = function(_, k, v)
			if obj[k] ~= nil and obj[k] ~= v then
				obj[k] = v
				obj._dirty = true
				if k == "Color" then frame.BackgroundColor3, stroke.Color = v,v end
				if k == "Transparency" then
					frame.BackgroundTransparency = obj.Filled and t(v) or 1
					stroke.Transparency = t(v)
				end
				if k == "Thickness" then stroke.Thickness = v end
				if k == "Filled" then frame.BackgroundTransparency = v and t(obj.Transparency) or 1; stroke.Enabled = not v end
				if k == "Visible" then frame.Visible = v end
				if k == "ZIndex" then frame.ZIndex = v end
			end
		end
	})
end

-- Square
local function newSquare()
	local frame = Instance.new("Frame")
	frame.BorderSizePixel = 0
	frame.AnchorPoint = Vector2.new(.5,.5)
	frame.Parent = DrawingUI
	local stroke = Instance.new("UIStroke", frame)
	stroke.LineJoinMode = Enum.LineJoinMode.Miter

	local obj = {
		Size = Vector2.zero,
		Position = Vector2.zero,
		Thickness = 1,
		Filled = false,
		Color = Color3.new(),
		Transparency = 1,
		Visible = true,
		ZIndex = 0,
		_dirty = true
	}

	function obj:_update()
		frame.Size = UDim2.fromOffset(self.Size.X, self.Size.Y)
		frame.Position = UDim2.fromOffset(self.Position.X, self.Position.Y)
	end

	renderQueue[obj] = true

	return setmetatable({}, {
		__index = function(_, k)
			if k == "Remove" or k == "Destroy" then return function() renderQueue[obj] = nil; frame:Destroy() end end
			if k == "Object" then return frame end
			return obj[k]
		end,
		__newindex = function(_, k, v)
			if obj[k] ~= nil and obj[k] ~= v then
				obj[k] = v
				obj._dirty = true
				if k == "Color" then frame.BackgroundColor3, stroke.Color = v,v end
				if k == "Transparency" then frame.BackgroundTransparency = obj.Filled and t(v) or 1; stroke.Transparency = t(v) end
				if k == "Thickness" then stroke.Thickness = v end
				if k == "Filled" then frame.BackgroundTransparency = v and t(obj.Transparency) or 1; stroke.Enabled = not v end
				if k == "Size" then frame.Size = UDim2.fromOffset(v.X,v.Y) end
				if k == "Position" then frame.Position = UDim2.fromOffset(v.X,v.Y) end
				if k == "Visible" then frame.Visible = v end
				if k == "ZIndex" then frame.ZIndex = v end
			end
		end
	})
end

-- Triangle
local function newTriangle()
	local A,B,C = newLine(),newLine(),newLine()
	return setmetatable({},{
		__index=function(_,k)
			if k=="Remove" or k=="Destroy" then return function() A:Remove();B:Remove();C:Remove() end end
			return nil
		end,
		__newindex=function(_,k,v)
			if k=="PointA" then A.From=v;B.To=v end
			if k=="PointB" then B.From=v;C.To=v end
			if k=="PointC" then C.From=v;A.To=v end
			if k=="Thickness" or k=="Color" or k=="Visible" or k=="ZIndex" then A[k],B[k],C[k]=v,v,v end
		end
	})
end

-- Quad
local function newQuad()
	local P1,P2,P3,P4 = newLine(),newLine(),newLine(),newLine()
	local obj = {Thickness=1,PointA=Vector2.new(),PointB=Vector2.new(),PointC=Vector2.new(),PointD=Vector2.new(),Filled=false}

	return setmetatable({},{
		__index=function(_,k)
			if k=="Remove" or k=="Destroy" then return function() P1:Remove();P2:Remove();P3:Remove();P4:Remove() end end
			return obj[k]
		end,
		__newindex=function(_,k,v)
			if k=="Thickness" then P1.Thickness=P2.Thickness=P3.Thickness=P4.Thickness=v end
			if k=="PointA" then P1.From=v;P2.To=v end
			if k=="PointB" then P2.From=v;P3.To=v end
			if k=="PointC" then P3.From=v;P4.To=v end
			if k=="PointD" then P4.From=v;P1.To=v end
			if k=="Visible" then P1.Visible=P2.Visible=P3.Visible=P4.Visible=v end
			if k=="Color" then P1.Color=P2.Color=P3.Color=P4.Color=v end
			if k=="ZIndex" then P1.ZIndex=P2.ZIndex=P3.ZIndex=P4.ZIndex=v end
		end
	})
end

-- Image
local function newImage()
	local frame = Instance.new("ImageLabel")
	frame.BorderSizePixel=0
	frame.ScaleType=Enum.ScaleType.Stretch
	frame.BackgroundTransparency=1
	frame.Parent = DrawingUI

	local obj = {Data="",DataURL="rbxassetid://0",Size=Vector2.zero,Position=Vector2.zero,Color=Color3.new(),Transparency=1,Visible=true,ZIndex=0}

	function obj:_update()
		frame.Size = UDim2.fromOffset(self.Size.X,self.Size.Y)
		frame.Position = UDim2.fromOffset(self.Position.X,self.Position.Y)
	end

	renderQueue[obj]=true

	return setmetatable({},{
		__index=function(_,k)
			if k=="Remove" or k=="Destroy" then return function() renderQueue[obj]=nil; frame:Destroy() end end
			if k=="Object" then return frame end
			if k=="Data" then return nil end
			return obj[k]
		end,
		__newindex=function(_,k,v)
			if obj[k]~=nil and obj[k]~=v then
				obj[k]=v
				obj._dirty=true
				if k=="DataURL" then frame.Image=v end
				if k=="Size" then frame.Size=UDim2.fromOffset(v.X,v.Y) end
				if k=="Position" then frame.Position=UDim2.fromOffset(v.X,v.Y) end
				if k=="Color" then frame.ImageColor3=v end
				if k=="Transparency" then frame.ImageTransparency=t(v) end
				if k=="Visible" then frame.Visible=v end
				if k=="ZIndex" then frame.ZIndex=v end
			end
		end
	})
end

function Drawing.new(t)
	if t=="Line" then return newLine()
	elseif t=="Text" then return newText()
	elseif t=="Circle" then return newCircle()
	elseif t=="Square" then return newSquare()
	elseif t=="Triangle" then return newTriangle()
	elseif t=="Quad" then return newQuad()
	elseif t=="Image" then return newImage()
	end
end

getgenv().Drawing = Drawing
