local coreGui = game:GetService("CoreGui")
local runService = game:GetService("RunService")

-- objects
local camera = workspace.CurrentCamera
local drawingUI = Instance.new("ScreenGui")
drawingUI.Name = "Drawing"
drawingUI.IgnoreGuiInset = true
drawingUI.DisplayOrder = 0x7fffffff
drawingUI.ResetOnSpawn = false
drawingUI.Parent = coreGui

-- variables
local drawingIndex = 0
local activeDrawings = {}

-- Optimized base object
local baseDrawingObj = {
	Visible = true,
	ZIndex = 0,
	Transparency = 1,
	Color = Color3.new(),
	Remove = function(self)
		setmetatable(self, nil)
	end,
	Destroy = function(self)
		setmetatable(self, nil)
	end
}

local drawingFontsEnum = {
	[0] = Font.fromEnum(Enum.Font.Roboto),
	[1] = Font.fromEnum(Enum.Font.Legacy),
	[2] = Font.fromEnum(Enum.Font.SourceSans),
	[3] = Font.fromEnum(Enum.Font.RobotoMono),
}

-- Optimized utility functions
local function getFontFromIndex(fontIndex: number): Font
	return drawingFontsEnum[math.clamp(fontIndex, 0, 3)]
end

local function convertTransparency(transparency: number): number
	return math.clamp(1 - transparency, 0, 1)
end

local function tableClone(t)
	local result = {}
	for k, v in pairs(t) do
		result[k] = v
	end
	return result
end

local function addBaseProperties(t)
	return setmetatable(t, {
		__index = baseDrawingObj
	})
end

-- main
local DrawingLib = {}
DrawingLib.Fonts = {
	["UI"] = 0,
	["System"] = 1,
	["Plex"] = 2,
	["Monospace"] = 3
}

function DrawingLib.new(drawingType)
	drawingIndex += 1
	
	if drawingType == "Line" then
		local lineObj = addBaseProperties({
			From = Vector2.zero,
			To = Vector2.zero,
			Thickness = 1
		})

		local lineFrame = Instance.new("Frame")
		lineFrame.Name = drawingIndex
		lineFrame.AnchorPoint = Vector2.new(0.5, 0.5)
		lineFrame.BorderSizePixel = 0
		lineFrame.BackgroundColor3 = lineObj.Color
		lineFrame.Visible = lineObj.Visible
		lineFrame.ZIndex = lineObj.ZIndex
		lineFrame.BackgroundTransparency = convertTransparency(lineObj.Transparency)
		lineFrame.Size = UDim2.new()
		lineFrame.Parent = drawingUI

		local mt = {
			__newindex = function(_, index, value)
				if index == "From" then
					lineObj.From = value
					local direction = lineObj.To - value
					local center = (lineObj.To + value) * 0.5
					local distance = direction.Magnitude
					local theta = math.deg(math.atan2(direction.Y, direction.X))

					lineFrame.Position = UDim2.fromOffset(center.X, center.Y)
					lineFrame.Rotation = theta
					lineFrame.Size = UDim2.fromOffset(distance, lineObj.Thickness)
				elseif index == "To" then
					lineObj.To = value
					local direction = value - lineObj.From
					local center = (value + lineObj.From) * 0.5
					local distance = direction.Magnitude
					local theta = math.deg(math.atan2(direction.Y, direction.X))

					lineFrame.Position = UDim2.fromOffset(center.X, center.Y)
					lineFrame.Rotation = theta
					lineFrame.Size = UDim2.fromOffset(distance, lineObj.Thickness)
				elseif index == "Thickness" then
					lineObj.Thickness = value
					local distance = (lineObj.To - lineObj.From).Magnitude
					lineFrame.Size = UDim2.fromOffset(distance, value)
				elseif index == "Visible" then
					lineObj.Visible = value
					lineFrame.Visible = value
				elseif index == "ZIndex" then
					lineObj.ZIndex = value
					lineFrame.ZIndex = value
				elseif index == "Transparency" then
					lineObj.Transparency = value
					lineFrame.BackgroundTransparency = convertTransparency(value)
				elseif index == "Color" then
					lineObj.Color = value
					lineFrame.BackgroundColor3 = value
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						if lineFrame then
							lineFrame:Destroy()
							lineFrame = nil
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				end
				return lineObj[index]
			end,
			__tostring = function() return "Drawing" end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
		
	elseif drawingType == "Text" then
		local textObj = addBaseProperties({
			Text = "",
			Font = DrawingLib.Fonts.UI,
			Size = 0,
			Position = Vector2.zero,
			Center = false,
			Outline = false,
			OutlineColor = Color3.new()
		})

		local textLabel = Instance.new("TextLabel")
		local uiStroke = Instance.new("UIStroke")
		
		textLabel.Name = drawingIndex
		textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		textLabel.BorderSizePixel = 0
		textLabel.BackgroundTransparency = 1
		textLabel.Visible = textObj.Visible
		textLabel.TextColor3 = textObj.Color
		textLabel.TextTransparency = convertTransparency(textObj.Transparency)
		textLabel.ZIndex = textObj.ZIndex
		textLabel.FontFace = getFontFromIndex(textObj.Font)
		textLabel.TextSize = textObj.Size
		textLabel.Text = ""
		textLabel.AutomaticSize = Enum.AutomaticSize.XY

		uiStroke.Thickness = 1
		uiStroke.Enabled = textObj.Outline
		uiStroke.Color = textObj.OutlineColor
		uiStroke.Parent = textLabel
		
		textLabel.Parent = drawingUI

		local function updatePosition()
			local textBounds = textLabel.TextBounds
			local offset = textBounds * 0.5
			textLabel.Position = UDim2.fromOffset(
				textObj.Position.X + (if not textObj.Center then offset.X else 0), 
				textObj.Position.Y + offset.Y
			)
		end

		local mt = {
			__newindex = function(_, index, value)
				if index == "Text" then
					textObj.Text = value
					textLabel.Text = value
					task.defer(updatePosition)
				elseif index == "Font" then
					textObj.Font = math.clamp(value, 0, 3)
					textLabel.FontFace = getFontFromIndex(textObj.Font)
				elseif index == "Size" then
					textObj.Size = value
					textLabel.TextSize = value
					task.defer(updatePosition)
				elseif index == "Position" then
					textObj.Position = value
					updatePosition()
				elseif index == "Center" then
					textObj.Center = value
					if value then
						local viewportSize = camera.ViewportSize
						textLabel.Position = UDim2.fromOffset(viewportSize.X * 0.5, viewportSize.Y * 0.5)
					else
						updatePosition()
					end
				elseif index == "Outline" then
					textObj.Outline = value
					uiStroke.Enabled = value
				elseif index == "OutlineColor" then
					textObj.OutlineColor = value
					uiStroke.Color = value
				elseif index == "Visible" then
					textObj.Visible = value
					textLabel.Visible = value
				elseif index == "ZIndex" then
					textObj.ZIndex = value
					textLabel.ZIndex = value
				elseif index == "Transparency" then
					textObj.Transparency = value
					local transparency = convertTransparency(value)
					textLabel.TextTransparency = transparency
					uiStroke.Transparency = transparency
				elseif index == "Color" then
					textObj.Color = value
					textLabel.TextColor3 = value
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						if textLabel then
							textLabel:Destroy()
							textLabel = nil
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				elseif index == "TextBounds" then
					return textLabel.TextBounds
				end
				return textObj[index]
			end,
			__tostring = function() return "Drawing" end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
		
	elseif drawingType == "Circle" then
		local circleObj = addBaseProperties({
			Radius = 150,
			Position = Vector2.zero,
			Thickness = 0.7,
			Filled = false,
			NumSides = 64
		})

		local circleFrame = Instance.new("Frame")
		local uiCorner = Instance.new("UICorner")
		local uiStroke = Instance.new("UIStroke")
		
		circleFrame.Name = drawingIndex
		circleFrame.AnchorPoint = Vector2.new(0.5, 0.5)
		circleFrame.BorderSizePixel = 0
		circleFrame.BackgroundTransparency = if circleObj.Filled then convertTransparency(circleObj.Transparency) else 1
		circleFrame.BackgroundColor3 = circleObj.Color
		circleFrame.Visible = circleObj.Visible
		circleFrame.ZIndex = circleObj.ZIndex

		uiCorner.CornerRadius = UDim.new(1, 0)
		uiCorner.Parent = circleFrame

		local diameter = circleObj.Radius * 2
		circleFrame.Size = UDim2.fromOffset(diameter, diameter)

		uiStroke.Thickness = circleObj.Thickness
		uiStroke.Enabled = not circleObj.Filled
		uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		uiStroke.Color = circleObj.Color
		uiStroke.Transparency = convertTransparency(circleObj.Transparency)
		uiStroke.Parent = circleFrame
		
		circleFrame.Parent = drawingUI

		local mt = {
			__newindex = function(_, index, value)
				if index == "Radius" then
					circleObj.Radius = value
					local diameter = value * 2
					circleFrame.Size = UDim2.fromOffset(diameter, diameter)
				elseif index == "Position" then
					circleObj.Position = value
					circleFrame.Position = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Thickness" then
					circleObj.Thickness = math.max(value, 0.6)
					uiStroke.Thickness = circleObj.Thickness
				elseif index == "Filled" then
					circleObj.Filled = value
					circleFrame.BackgroundTransparency = if value then convertTransparency(circleObj.Transparency) else 1
					uiStroke.Enabled = not value
				elseif index == "Visible" then
					circleObj.Visible = value
					circleFrame.Visible = value
				elseif index == "ZIndex" then
					circleObj.ZIndex = value
					circleFrame.ZIndex = value
				elseif index == "Transparency" then
					circleObj.Transparency = value
					local transparency = convertTransparency(value)
					circleFrame.BackgroundTransparency = if circleObj.Filled then transparency else 1
					uiStroke.Transparency = transparency
				elseif index == "Color" then
					circleObj.Color = value
					circleFrame.BackgroundColor3 = value
					uiStroke.Color = value
				elseif index == "NumSides" then
					circleObj.NumSides = value
					-- Ignored for optimization, always circular
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						if circleFrame then
							circleFrame:Destroy()
							circleFrame = nil
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				end
				return circleObj[index]
			end,
			__tostring = function() return "Drawing" end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
		
	elseif drawingType == "Square" or drawingType == "Rectangle" then
		local squareObj = addBaseProperties({
			Size = Vector2.zero,
			Position = Vector2.zero,
			Thickness = 0.7,
			Filled = false
		})

		local squareFrame = Instance.new("Frame")
		local uiStroke = Instance.new("UIStroke")
		
		squareFrame.Name = drawingIndex
		squareFrame.BorderSizePixel = 0
		squareFrame.BackgroundTransparency = if squareObj.Filled then convertTransparency(squareObj.Transparency) else 1
		squareFrame.ZIndex = squareObj.ZIndex
		squareFrame.BackgroundColor3 = squareObj.Color
		squareFrame.Visible = squareObj.Visible

		uiStroke.Thickness = squareObj.Thickness
		uiStroke.Enabled = not squareObj.Filled
		uiStroke.LineJoinMode = Enum.LineJoinMode.Miter
		uiStroke.Color = squareObj.Color
		uiStroke.Transparency = convertTransparency(squareObj.Transparency)
		uiStroke.Parent = squareFrame
		
		squareFrame.Parent = drawingUI

		local mt = {
			__newindex = function(_, index, value)
				if index == "Size" then
					squareObj.Size = value
					squareFrame.Size = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Position" then
					squareObj.Position = value
					squareFrame.Position = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Thickness" then
					squareObj.Thickness = math.max(value, 0.6)
					uiStroke.Thickness = squareObj.Thickness
				elseif index == "Filled" then
					squareObj.Filled = value
					squareFrame.BackgroundTransparency = if value then convertTransparency(squareObj.Transparency) else 1
					uiStroke.Enabled = not value
				elseif index == "Visible" then
					squareObj.Visible = value
					squareFrame.Visible = value
				elseif index == "ZIndex" then
					squareObj.ZIndex = value
					squareFrame.ZIndex = value
				elseif index == "Transparency" then
					squareObj.Transparency = value
					local transparency = convertTransparency(value)
					squareFrame.BackgroundTransparency = if squareObj.Filled then transparency else 1
					uiStroke.Transparency = transparency
				elseif index == "Color" then
					squareObj.Color = value
					uiStroke.Color = value
					squareFrame.BackgroundColor3 = value
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						if squareFrame then
							squareFrame:Destroy()
							squareFrame = nil
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				end
				return squareObj[index]
			end,
			__tostring = function() return "Drawing" end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
		
	elseif drawingType == "Image" then
		local imageObj = addBaseProperties({
			Data = "",
			Size = Vector2.zero,
			Position = Vector2.zero,
			Rounding = 0
		})

		local imageFrame = Instance.new("ImageLabel")
		imageFrame.Name = drawingIndex
		imageFrame.BorderSizePixel = 0
		imageFrame.ScaleType = Enum.ScaleType.Stretch
		imageFrame.BackgroundTransparency = 1
		imageFrame.Visible = imageObj.Visible
		imageFrame.ZIndex = imageObj.ZIndex
		imageFrame.ImageTransparency = convertTransparency(imageObj.Transparency)
		imageFrame.ImageColor3 = imageObj.Color
		imageFrame.Parent = drawingUI

		local mt = {
			__newindex = function(_, index, value)
				if index == "Data" then
					imageObj.Data = value
					imageFrame.Image = value
				elseif index == "Size" then
					imageObj.Size = value
					imageFrame.Size = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Position" then
					imageObj.Position = value
					imageFrame.Position = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Rounding" then
					imageObj.Rounding = value
					-- Could add UICorner here if needed
				elseif index == "Visible" then
					imageObj.Visible = value
					imageFrame.Visible = value
				elseif index == "ZIndex" then
					imageObj.ZIndex = value
					imageFrame.ZIndex = value
				elseif index == "Transparency" then
					imageObj.Transparency = value
					imageFrame.ImageTransparency = convertTransparency(value)
				elseif index == "Color" then
					imageObj.Color = value
					imageFrame.ImageColor3 = value
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						if imageFrame then
							imageFrame:Destroy()
							imageFrame = nil
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				end
				return imageObj[index]
			end,
			__tostring = function() return "Drawing" end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
		
	elseif drawingType == "Quad" then
		local quadObj = addBaseProperties({
			Thickness = 1,
			PointA = Vector2.zero,
			PointB = Vector2.zero,
			PointC = Vector2.zero,
			PointD = Vector2.zero,
			Filled = false
		})

		local lines = {
			A = DrawingLib.new("Line"),
			B = DrawingLib.new("Line"),
			C = DrawingLib.new("Line"),
			D = DrawingLib.new("Line")
		}

		local mt = {
			__newindex = function(_, index, value)
				if index == "Thickness" then
					quadObj.Thickness = value
					for _, line in pairs(lines) do
						line.Thickness = value
					end
				elseif index == "PointA" then
					quadObj.PointA = value
					lines.A.From = value
					lines.B.To = value
				elseif index == "PointB" then
					quadObj.PointB = value
					lines.B.From = value
					lines.C.To = value
				elseif index == "PointC" then
					quadObj.PointC = value
					lines.C.From = value
					lines.D.To = value
				elseif index == "PointD" then
					quadObj.PointD = value
					lines.D.From = value
					lines.A.To = value
				elseif index == "Visible" then
					quadObj.Visible = value
					for _, line in pairs(lines) do
						line.Visible = value
					end
				elseif index == "Color" then
					quadObj.Color = value
					for _, line in pairs(lines) do
						line.Color = value
					end
				elseif index == "ZIndex" then
					quadObj.ZIndex = value
					for _, line in pairs(lines) do
						line.ZIndex = value
					end
				elseif index == "Transparency" then
					quadObj.Transparency = value
					for _, line in pairs(lines) do
						line.Transparency = value
					end
				elseif index == "Filled" then
					quadObj.Filled = value
					-- Not implemented
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						for _, line in pairs(lines) do
							line:Remove()
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				end
				return quadObj[index]
			end,
			__tostring = function() return "Drawing" end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
		
	elseif drawingType == "Triangle" then
		local triangleObj = addBaseProperties({
			PointA = Vector2.zero,
			PointB = Vector2.zero,
			PointC = Vector2.zero,
			Thickness = 1,
			Filled = false
		})

		local lines = {
			A = DrawingLib.new("Line"),
			B = DrawingLib.new("Line"),
			C = DrawingLib.new("Line")
		}

		local mt = {
			__tostring = function() return "Drawing" end,
			__newindex = function(_, index, value)
				if index == "PointA" then
					triangleObj.PointA = value
					lines.A.From = value
					lines.B.To = value
				elseif index == "PointB" then
					triangleObj.PointB = value
					lines.B.From = value
					lines.C.To = value
				elseif index == "PointC" then
					triangleObj.PointC = value
					lines.C.From = value
					lines.A.To = value
				elseif index == "Thickness" or index == "Visible" or index == "Color" or index == "ZIndex" or index == "Transparency" then
					triangleObj[index] = value
					for _, line in pairs(lines) do
						line[index] = value
					end
				elseif index == "Filled" then
					triangleObj.Filled = value
					-- Not implemented
				end
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						for _, line in pairs(lines) do
							line:Remove()
						end
						activeDrawings[self] = nil
						setmetatable(self, nil)
					end
				end
				return triangleObj[index]
			end
		}
		
		local drawing = setmetatable({}, mt)
		activeDrawings[drawing] = true
		return drawing
	end
end

-- Clean up on game close
game:GetService("Players").LocalPlayer.AncestryChanged:Connect(function()
	for drawing in pairs(activeDrawings) do
		pcall(function()
			drawing:Remove()
		end)
	end
end)

getgenv().Drawing = DrawingLib
return DrawingLib
