local espLibrary = {
    instances = {},
    espCache = {},
    chamsCache = {},
    objectCache = {},
    conns = {},
    whitelist = {},
    blacklist = {},
    options = {
        enabled = true,
        minScaleFactorX = 3,
        maxScaleFactorX = 3,
        minScaleFactorY = 4,
        maxScaleFactorY = 5,
        scaleFactorX = 5,
        scaleFactorY = 6,
        boundingBox = false,
        boundingBoxDescending = true,
        excludedPartNames = {},
        font = Enum.Font.Code,
        fontSize = 13,
        limitDistance = false,
        maxDistance = 1000,
        visibleOnly = false,
        teamCheck = false,
        teamColor = false,
        fillColor = nil,
        whitelistColor = Color3.new(1, 0, 0),
        outOfViewArrows = true,
        outOfViewArrowsFilled = true,
        outOfViewArrowsSize = 25,
        outOfViewArrowsRadius = 100,
        outOfViewArrowsColor = Color3.new(1, 1, 1),
        outOfViewArrowsTransparency = 0.5,
        outOfViewArrowsOutline = true,
        outOfViewArrowsOutlineFilled = false,
        outOfViewArrowsOutlineColor = Color3.new(1, 1, 1),
        outOfViewArrowsOutlineTransparency = 1,
        names = true,
        nameTransparency = 1,
        nameColor = Color3.new(1, 1, 1),
        boxes = true,
        boxesTransparency = 1,
        boxesColor = Color3.new(1, 0, 0),
        boxFill = false,
        boxFillTransparency = 0.5,
        boxFillColor = Color3.new(1, 0, 0),
        healthBars = true,
        healthBarsSize = 1,
        toolNameTransparency = 1,
        toolNameColor = Color3.new(1, 1, 1),
        healthBarsTransparency = 1,
        healthBarsColor = Color3.new(0, 1, 0),
        healthText = false,
        healthTextTransparency = 1,
        healthTextSuffix = "%",
        healthTextColor = Color3.new(1, 1, 1),
        distance = true,
        distanceTransparency = 1,
        distanceSuffix = "M",
        distanceColor = Color3.new(1, 1, 1),
        tracers = false,
        tracerTransparency = 1,
        tracerColor = Color3.new(1, 1, 1),
        tracerOrigin = "Bottom",
        chams = true,
        chamsFillColor = Color3.new(1, 0, 0),
        chamsFillTransparency = 0.5,
        toolName = true,
        chamsOutlineColor = Color3.new(),
        chamsOutlineTransparency = 0,
        image = true,
        glowImage = false,
        FILLbox = false,
        statesEnabled = true,
        statesColor = Color3.new(1, 1, 1),
        customStatesEnabled = true,
        teamEspEnabled = true,
        teamMyColor = Color3.new(0, 1, 0),
        teamEnemyColor = Color3.new(1, 0, 0),
    },
}

espLibrary.__index = espLibrary

-- Variables
local getService = game.GetService
local instanceNew = Instance.new
local vector2New = Vector2.new
local vector3New = Vector3.new
local cframeNew = CFrame.new
local color3New = Color3.new
local raycastParamsNew = RaycastParams.new
local abs = math.abs
local tan = math.tan
local rad = math.rad
local clamp = math.clamp
local floor = math.floor
local find = table.find
local insert = table.insert
local findFirstChild = game.FindFirstChild
local getChildren = game.GetChildren
local getDescendants = game.GetDescendants
local isA = workspace.IsA
local raycast = workspace.Raycast
local emptyCFrame = cframeNew()
local pointToObjectSpace = emptyCFrame.PointToObjectSpace
local getComponents = emptyCFrame.GetComponents
local cross = vector3New().Cross
local inf = 1 / 0

-- Services
local workspace = getService(game, "Workspace")
local runService = getService(game, "RunService")
local players = getService(game, "Players")
local coreGui = getService(game, "CoreGui")
local userInputService = getService(game, "UserInputService")

-- Cache
local currentCamera = workspace.CurrentCamera
local localPlayer = players.LocalPlayer
local screenGui = instanceNew("ScreenGui")
screenGui.Name = "EspScreenGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = coreGui
local lastFov, lastScale

-- Instance functions
local wtvp = currentCamera.WorldToViewportPoint

_G.glowcolor = Color3.new(1, 1, 1)
_G.GradientColor1 = Color3.new(1, 1, 1)
_G.GradientColor2 = Color3.new(1, 1, 1)
_G.GradientColor3 = Color3.new(1, 1, 1)
_G.GradientSpin = false
_G.GradientSpinSpeed = 180

local function create(type, properties)
    local object = instanceNew(type)
    
    if properties then
        for i, v in next, properties do
            object[i] = v
        end
    end
    
    insert(espLibrary.instances, object)
    return object
end

local function worldToViewportPoint(position)
    local screenPosition, onScreen = wtvp(currentCamera, position)
    return vector2New(screenPosition.X, screenPosition.Y), onScreen, screenPosition.Z
end

local function round(number)
    return typeof(number) == "Vector2" and vector2New(round(number.X), round(number.Y)) or floor(number)
end

-- Main Functions
function espLibrary.getTeam(player)
    local team = player.Team
    return team, player.TeamColor.Color
end

function espLibrary.getCharacter(player)
    local character = player.Character
    return character, character and findFirstChild(character, "HumanoidRootPart")
end

function espLibrary.getBoundingBox(character, torso)
    if espLibrary.options.boundingBox then
        local minX, minY, minZ = inf, inf, inf
        local maxX, maxY, maxZ = -inf, -inf, -inf
        
        for _, part in next, espLibrary.options.boundingBoxDescending and getDescendants(character) or getChildren(character) do
            if isA(part, "BasePart") and not find(espLibrary.options.excludedPartNames, part.Name) then
                local size = part.Size
                local sizeX, sizeY, sizeZ = size.X, size.Y, size.Z
                
                local x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22 = getComponents(part.CFrame)
                
                local wiseX = 0.5 * (abs(r00) * sizeX + abs(r01) * sizeY + abs(r02) * sizeZ)
                local wiseY = 0.5 * (abs(r10) * sizeX + abs(r11) * sizeY + abs(r12) * sizeZ)
                local wiseZ = 0.5 * (abs(r20) * sizeX + abs(r21) * sizeY + abs(r22) * sizeZ)
                
                minX = minX > x - wiseX and x - wiseX or minX
                minY = minY > y - wiseY and y - wiseY or minY
                minZ = minZ > z - wiseZ and z - wiseZ or minZ
                
                maxX = maxX < x + wiseX and x + wiseX or maxX
                maxY = maxY < y + wiseY and y + wiseY or maxY
                maxZ = maxZ < z + wiseZ and z + wiseZ or maxZ
            end
        end
        
        local oMin, oMax = vector3New(minX, minY, minZ), vector3New(maxX, maxY, maxZ)
        return (oMax + oMin) * 0.5, oMax - oMin
    else
        return torso.Position, vector2New(espLibrary.options.scaleFactorX, espLibrary.options.scaleFactorY)
    end
end

function espLibrary.getScaleFactor(fov, depth)
    if fov ~= lastFov then
        lastScale = tan(rad(fov * 0.5)) * 2
        lastFov = fov
    end
    
    return 1 / (depth * lastScale) * 1000
end

function espLibrary.getBoxData(position, size)
    local torsoPosition, onScreen, depth = worldToViewportPoint(position)
    local scaleFactor = espLibrary.getScaleFactor(currentCamera.FieldOfView, depth)
    
    local clampX = clamp(size.X, espLibrary.options.minScaleFactorX, espLibrary.options.maxScaleFactorX)
    local clampY = clamp(size.Y, espLibrary.options.minScaleFactorY, espLibrary.options.maxScaleFactorY)
    local size = round(vector2New(clampX * scaleFactor, clampY * scaleFactor))
    
    return onScreen, size, round(vector2New(torsoPosition.X - (size.X * 0.5), torsoPosition.Y - (size.Y * 0.5))), torsoPosition
end

function espLibrary.getHealth(player, character)
    local humanoid = findFirstChild(character, "Humanoid")
    
    if humanoid then
        return humanoid.Health, humanoid.MaxHealth
    end
    
    return 100, 100
end

function espLibrary.visibleCheck(character, position)
    local origin = currentCamera.CFrame.Position
    local params = raycastParamsNew()
    
    params.FilterDescendantsInstances = { espLibrary.getCharacter(localPlayer), currentCamera, character }
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    return (not raycast(workspace, origin, position - origin, params))
end

-- GUI Creation Functions
local function createFrame(properties)
    local frame = create("Frame", {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderSizePixel = 0,
        Parent = screenGui,
        Visible = false
    })
    
    if properties then
        for k, v in pairs(properties) do
            frame[k] = v
        end
    end
    
    return frame
end

local function createTextLabel(properties)
    local label = create("TextLabel", {
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Font = espLibrary.options.font,
        TextSize = espLibrary.options.fontSize,
        TextColor3 = Color3.new(1, 1, 1),
        Parent = screenGui,
        Visible = false,
        TextStrokeTransparency = 0,
        TextStrokeColor3 = Color3.new(0, 0, 0)
    })
    
    if properties then
        for k, v in pairs(properties) do
            label[k] = v
        end
    end
    
    return label
end

local function addStroke(element, thickness, color)
    local stroke = create("UIStroke", {
        Thickness = thickness or 1,
        Color = color or Color3.new(0, 0, 0),
        Parent = element
    })
    return stroke
end

function espLibrary.addEsp(player)
    if player == localPlayer then
        return
    end
    
    -- Create top name label
    local topLabel = createTextLabel({
        Name = "TopLabel",
        TextXAlignment = Enum.TextXAlignment.Center,
        TextYAlignment = Enum.TextYAlignment.Bottom
    })
    
    -- Create health text label (side)
    local healthTextLabel = createTextLabel({
        Name = "HealthText",
        TextXAlignment = Enum.TextXAlignment.Left,
        TextYAlignment = Enum.TextYAlignment.Top
    })
    
    -- Create state text label
    local stateTextLabel = createTextLabel({
        Name = "StateText",
        TextXAlignment = Enum.TextXAlignment.Left,
        TextYAlignment = Enum.TextYAlignment.Top
    })
    
    -- Create team text label
    local teamTextLabel = createTextLabel({
        Name = "TeamText",
        TextXAlignment = Enum.TextXAlignment.Left,
        TextYAlignment = Enum.TextYAlignment.Top
    })
    
    -- Create distance label (bottom)
    local distanceLabel = createTextLabel({
        Name = "DistanceLabel",
        TextXAlignment = Enum.TextXAlignment.Center,
        TextYAlignment = Enum.TextYAlignment.Top
    })
    
    -- Create tool name label (bottom)
    local toolLabel = createTextLabel({
        Name = "ToolLabel",
        TextXAlignment = Enum.TextXAlignment.Center,
        TextYAlignment = Enum.TextYAlignment.Top
    })
    
    -- Create box outline
    local boxOutline = createFrame({
        Name = "BoxOutline",
        BackgroundColor3 = Color3.new(0, 0, 0),
        BackgroundTransparency = 0
    })
    
    -- Create box
    local box = createFrame({
        Name = "Box",
        BackgroundTransparency = 1
    })
    addStroke(box, 1, Color3.new(1, 0, 0))
    
    -- Create box fill with glow
    local boxFill = createFrame({
        Name = "BoxFill",
        BackgroundTransparency = 0.5
    })
    
    local gradient = create("UIGradient", {
        Name = "BoxGradient",
        Rotation = 90,
        Parent = boxFill
    })
    
    local glow = nil
    if espLibrary.options.glowImage then
        glow = create("ImageLabel", {
            Name = "Glow",
            BackgroundTransparency = 1,
            Image = "rbxassetid://18245826428",
            ImageColor3 = _G.glowcolor,
            ImageTransparency = 0.8,
            ScaleType = Enum.ScaleType.Slice,
            SliceCenter = Rect.new(21, 21, 79, 79),
            Size = UDim2.new(1, 40, 1, 40),
            Position = UDim2.new(0, -20, 0, -20),
            ZIndex = 0,
            Visible = false,
            Parent = boxFill
        })
    end
    
    -- Create health bar outline
    local healthBarOutline = createFrame({
        Name = "HealthBarOutline",
        BackgroundColor3 = Color3.new(0, 0, 0),
        BackgroundTransparency = 0
    })
    
    -- Create health bar with gradient
    local healthBar = createFrame({
        Name = "HealthBar",
        BackgroundColor3 = Color3.new(0, 1, 0),
        BackgroundTransparency = 0
    })
    
    local healthGradient = create("UIGradient", {
        Name = "HealthGradient",
        Rotation = 270,
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
            ColorSequenceKeypoint.new(1, Color3.new(1, 0.5, 0))
        }),
        Parent = healthBar
    })
    
    -- Create tracer line
    local tracerLine = createFrame({
        Name = "TracerLine",
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderSizePixel = 0,
        AnchorPoint = Vector2.new(0.5, 0.5)
    })
    
    -- Create arrows (triangle approximation using rotated frames)
    local arrow = createFrame({
        Name = "Arrow",
        BackgroundColor3 = Color3.new(1, 1, 1),
        Size = UDim2.new(0, 25, 0, 25),
        AnchorPoint = Vector2.new(0.5, 0.5),
        Rotation = 0
    })
    
    local arrowOutline = createFrame({
        Name = "ArrowOutline",
        BackgroundColor3 = Color3.new(1, 1, 1),
        Size = UDim2.new(0, 27, 0, 27),
        AnchorPoint = Vector2.new(0.5, 0.5),
        Rotation = 0
    })
    
    local objects = {
        arrow = arrow,
        arrowOutline = arrowOutline,
        top = topLabel,
        side = healthTextLabel,
        bottom = distanceLabel,
        stateText = stateTextLabel,
        teamText = teamTextLabel,
        tool = toolLabel,
        boxFill = boxFill,
        boxOutline = boxOutline,
        box = box,
        healthBarOutline = healthBarOutline,
        healthBar = healthBar,
        line = tracerLine,
        glow = glow,
        gradient = gradient,
        healthGradient = healthGradient
    }
    
    espLibrary.espCache[player] = objects
end

function espLibrary.removeEsp(player)
    local espCache = espLibrary.espCache[player]
    
    if espCache then
        espLibrary.espCache[player] = nil
        
        for index, object in next, espCache do
            espCache[index] = nil
            if object and typeof(object) == "Instance" then
                object:Destroy()
            end
        end
    end
end

function espLibrary.addChams(player)
    if player == localPlayer then
        return
    end
    
    espLibrary.chamsCache[player] = create("Highlight", {
        Parent = screenGui,
    })
end

function espLibrary.removeChams(player)
    local highlight = espLibrary.chamsCache[player]
    
    if highlight then
        espLibrary.chamsCache[player] = nil
        highlight:Destroy()
    end
end

function espLibrary.addObject(object, options)
    espLibrary.objectCache[object] = {
        options = options,
        text = createTextLabel({
            TextXAlignment = Enum.TextXAlignment.Center,
            TextYAlignment = Enum.TextYAlignment.Center
        })
    }
end

function espLibrary.removeObject(object)
    local cache = espLibrary.objectCache[object]
    
    if cache then
        espLibrary.objectCache[object] = nil
        cache.text:Destroy()
    end
end

function espLibrary:AddObjectEsp(object, defaultOptions)
    assert(object and object.Parent, "invalid object passed")
    
    local options = defaultOptions or {}
    
    options.enabled = options.enabled or true
    options.limitDistance = options.limitDistance or false
    options.maxDistance = options.maxDistance or false
    options.visibleOnly = options.visibleOnly or false
    options.color = options.color or color3New(1, 1, 1)
    options.transparency = options.transparency or 1
    options.text = options.text or object.Name
    options.font = options.font or Enum.Font.Code
    options.fontSize = options.fontSize or 13
    
    self.addObject(object, options)
    
    insert(self.conns, object.Parent.ChildRemoved:Connect(function(child)
        if child == object then
            self.removeObject(child)
        end
    end))
    
    return options
end

function espLibrary:Unload()
    for _, connection in next, self.conns do
        connection:Disconnect()
    end
    
    for _, player in next, players:GetPlayers() do
        self.removeEsp(player)
        self.removeChams(player)
    end
    
    for object, _ in next, self.objectCache do
        self.removeObject(object)
    end
    
    for _, object in next, self.instances do
        object:Destroy()
    end
    
    screenGui:Destroy()
    runService:UnbindFromRenderStep("esp_rendering")
end

function espLibrary:Load(renderValue)
    insert(self.conns, players.PlayerAdded:Connect(function(player)
        self.addEsp(player)
        self.addChams(player)
    end))
    
    insert(self.conns, players.PlayerRemoving:Connect(function(player)
        self.removeEsp(player)
        self.removeChams(player)
    end))
    
    espLibrary.options.glowImage = true
    
    for _, player in next, players:GetPlayers() do
        self.addEsp(player)
        self.addChams(player)
    end
    
    runService:BindToRenderStep("esp_rendering", renderValue or (Enum.RenderPriority.Camera.Value + 1), function()
        for player, objects in next, self.espCache do
            local character, torso = self.getCharacter(player)
            
            if character and torso then
                local onScreen, size, position, torsoPosition = self.getBoxData(torso.Position, Vector3.new(5, 6))
                local distance = (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and (localPlayer.Character.HumanoidRootPart.Position - torso.Position).Magnitude) or 0
                
                local canShow, enabled = onScreen and (size and position), self.options.enabled
                local team, teamColor = self.getTeam(player)
                local color = self.options.teamColor and teamColor or nil
                
                if self.options.fillColor ~= nil then
                    color = self.options.fillColor
                end
                
                if find(self.whitelist, player.Name) then
                    color = self.options.whitelistColor
                end
                
                if find(self.blacklist, player.Name) then
                    enabled = false
                end
                
                if self.options.limitDistance and distance > self.options.maxDistance then
                    enabled = false
                end
                
                if self.options.visibleOnly and not self.visibleCheck(character, torso.Position) then
                    enabled = false
                end
                
                if self.options.teamCheck and (team == self.getTeam(localPlayer)) then
                    enabled = false
                end
                
                local viewportSize = currentCamera.ViewportSize
                local screenCenter = vector2New(viewportSize.X / 2, viewportSize.Y / 2)
                local objectSpacePoint = (pointToObjectSpace(currentCamera.CFrame, torso.Position) * vector3New(1, 0, 1)).Unit
                local crossVector = cross(objectSpacePoint, vector3New(0, 1, 1))
                local rightVector = vector2New(crossVector.X, crossVector.Z)
                
                local arrowRadius, arrowSize = self.options.outOfViewArrowsRadius, self.options.outOfViewArrowsSize
                local arrowPosition = screenCenter + vector2New(objectSpacePoint.X, objectSpacePoint.Z) * arrowRadius
                local arrowDirection = (arrowPosition - screenCenter).Unit
                
                local health, maxHealth = self.getHealth(player, character)
                local healthBarSize = round(vector2New(self.options.healthBarsSize, -(size.Y * (health / maxHealth))))
                local healthBarPosition = round(vector2New(position.X - (3 + healthBarSize.X), position.Y + size.Y))
                
                local show = canShow and enabled
                
                -- Arrow visibility
                objects.arrow.Visible = (not canShow and enabled) and self.options.outOfViewArrows
                objects.arrow.BackgroundTransparency = 1 - self.options.outOfViewArrowsTransparency
                objects.arrow.BackgroundColor3 = color or self.options.outOfViewArrowsColor
                objects.arrow.Position = UDim2.new(0, arrowPosition.X, 0, arrowPosition.Y)
                objects.arrow.Rotation = math.deg(math.atan2(arrowDirection.Y, arrowDirection.X)) + 90
                
                objects.arrowOutline.Visible = (not canShow and enabled) and self.options.outOfViewArrowsOutline
                objects.arrowOutline.BackgroundTransparency = 1 - self.options.outOfViewArrowsOutlineTransparency
                objects.arrowOutline.BackgroundColor3 = color or self.options.outOfViewArrowsOutlineColor
                objects.arrowOutline.Position = UDim2.new(0, arrowPosition.X, 0, arrowPosition.Y)
                objects.arrowOutline.Rotation = math.deg(math.atan2(arrowDirection.Y, arrowDirection.X)) + 90
                
                -- Top name label - positioned at (pos.X + size.X/2, pos.Y - 15)
                objects.top.Visible = show and self.options.names
                objects.top.TextSize = self.options.fontSize
                objects.top.TextTransparency = 1 - self.options.nameTransparency
                objects.top.TextColor3 = color or self.options.nameColor
                objects.top.Text = player.Name
                objects.top.Size = UDim2.new(0, objects.top.TextBounds.X, 0, objects.top.TextBounds.Y)
                objects.top.Position = UDim2.new(0, position.X + size.X / 2, 0, position.Y - 15)
                
                -- Side stack - Health Text (top-right)
                local sideOffset = 0
                
                objects.side.Visible = show and self.options.healthText
                objects.side.TextSize = self.options.fontSize
                objects.side.TextTransparency = 1 - self.options.healthTextTransparency
                objects.side.TextColor3 = color or self.options.healthTextColor
                objects.side.Text = math.round(health) .. self.options.healthTextSuffix
                objects.side.Size = UDim2.new(0, objects.side.TextBounds.X, 0, objects.side.TextBounds.Y)
                objects.side.Position = UDim2.new(0, position.X + size.X + 3, 0, position.Y - 3 + sideOffset)
                
                if objects.side.Visible then
                    sideOffset = sideOffset + 13
                end
                
                -- State Text (stacked below health if both enabled)
                objects.stateText.Visible = false
                if character and torso then
                    local humanoid = findFirstChild(character, "Humanoid")
                    if humanoid then
                        local state = humanoid:GetState()
                        local vel = torso.AssemblyLinearVelocity
                        local horizontalVel = Vector3.new(vel.X, 0, vel.Z).Magnitude
                        local verticalVel = vel.Y
                        
                        local finalState = ""
                        
                        if state == Enum.HumanoidStateType.Jumping then
                            finalState = "Jumping"
                        elseif state == Enum.HumanoidStateType.Freefall then
                            if verticalVel < -60 then
                                finalState = "Freefalling"
                            elseif verticalVel < -8 then
                                finalState = "Falling"
                            else
                                finalState = "Jumping"
                            end
                        elseif state == Enum.HumanoidStateType.Running then
                            finalState = horizontalVel <= 0.1 and "Idle" or "Moving"
                        else
                            local rename = {
                                FallingDown = "Falling",
                                RunningNoPhysics = "Running",
                                StrafingNoPhysics = "Strafing",
                                PlatformStanding = "Platform",
                                GettingUp = "GetUp",
                                Running = "Moving",
                            }
                            finalState = rename[state.Name] or state.Name
                        end
                        
                        objects.stateText.Visible = show and espLibrary.options.statesEnabled
                        objects.stateText.TextSize = math.max(10, espLibrary.options.fontSize - 3)
                        objects.stateText.Position = UDim2.new(0, position.X + size.X + 3, 0, position.Y - 3 + sideOffset)
                        objects.stateText.Text = finalState
                        objects.stateText.TextColor3 = espLibrary.options.statesColor
                        objects.stateText.Size = UDim2.new(0, objects.stateText.TextBounds.X, 0, objects.stateText.TextBounds.Y)
                        objects.stateText.TextTransparency = 0
                        
                        if objects.stateText.Visible then
                            sideOffset = sideOffset + 13
                        end
                    end
                end
                
                -- Team Text (stacked below state if enabled)
                objects.teamText.Visible = false
                if character and torso then
                    local myTeam = localPlayer.Team
                    local targetTeam = player.Team
                    
                    objects.teamText.Visible = show and espLibrary.options.teamEspEnabled
                    objects.teamText.TextSize = math.max(10, espLibrary.options.fontSize - 3)
                    objects.teamText.Position = UDim2.new(0, position.X + size.X + 3, 0, position.Y - 3 + sideOffset)
                    objects.teamText.Text = targetTeam and targetTeam.Name or "None"
                    objects.teamText.Size = UDim2.new(0, objects.teamText.TextBounds.X, 0, objects.teamText.TextBounds.Y)
                    objects.teamText.TextTransparency = 0
                    
                    if targetTeam == myTeam then
                        objects.teamText.TextColor3 = espLibrary.options.teamMyColor
                    else
                        objects.teamText.TextColor3 = espLibrary.options.teamEnemyColor
                    end
                end
                
                -- Bottom stack - Distance
                local bottomOffset = 0
                
                objects.bottom.Visible = show and self.options.distance
                objects.bottom.TextSize = self.options.fontSize
                objects.bottom.TextTransparency = 1 - self.options.distanceTransparency
                objects.bottom.TextColor3 = color or self.options.nameColor
                objects.bottom.Text = "[" .. tostring(round(distance)) .. self.options.distanceSuffix .. "]"
                objects.bottom.Size = UDim2.new(0, objects.bottom.TextBounds.X, 0, objects.bottom.TextBounds.Y)
                objects.bottom.Position = UDim2.new(0, position.X + size.X / 2, 0, position.Y + size.Y + 1 + bottomOffset)
                
                if objects.bottom.Visible then
                    bottomOffset = bottomOffset + objects.bottom.TextBounds.Y + 1
                end
                
                -- Tool Name (stacked below distance)
                local tName = ""
                local char = player.Character
                
                if char then
                    local tl = char:FindFirstChildOfClass("Tool")
                    if tl then
                        tName = tl.Name
                    end
                end
                
                objects.tool.Visible = show and self.options.toolName and tName ~= ""
                objects.tool.TextSize = self.options.fontSize
                objects.tool.TextTransparency = 1 - self.options.toolNameTransparency
                objects.tool.TextColor3 = self.options.toolNameColor
                objects.tool.Text = tName
                objects.tool.Size = UDim2.new(0, objects.tool.TextBounds.X, 0, objects.tool.TextBounds.Y)
                objects.tool.Position = UDim2.new(0, position.X + size.X / 2, 0, position.Y + size.Y + 1 + bottomOffset)
                
                -- Box
                objects.box.Visible = show and self.options.boxes
                local boxStroke = objects.box:FindFirstChildOfClass("UIStroke")
                if boxStroke then
                    boxStroke.Color = color or self.options.boxesColor
                    boxStroke.Transparency = 1 - self.options.boxesTransparency
                end
                objects.box.Size = UDim2.new(0, size.X, 0, size.Y)
                objects.box.Position = UDim2.new(0, position.X, 0, position.Y)
                
                objects.boxOutline.Visible = show and self.options.boxes
                objects.boxOutline.BackgroundTransparency = 1 - self.options.boxesTransparency
                objects.boxOutline.Size = UDim2.new(0, size.X, 0, size.Y)
                objects.boxOutline.Position = UDim2.new(0, position.X, 0, position.Y)
                
                -- Box Fill with Gradient
                objects.boxFill.Visible = show and self.options.boxFill
                objects.boxFill.BackgroundTransparency = 1 - self.options.boxFillTransparency
                objects.boxFill.BackgroundColor3 = color or self.options.boxFillColor
                objects.boxFill.Size = UDim2.new(0, size.X, 0, size.Y)
                objects.boxFill.Position = UDim2.new(0, position.X, 0, position.Y)
                
                if objects.gradient then
                    objects.gradient.Color = ColorSequence.new({
                        ColorSequenceKeypoint.new(0, _G.GradientColor1),
                        ColorSequenceKeypoint.new(0.5, _G.GradientColor2),
                        ColorSequenceKeypoint.new(1, _G.GradientColor3),
                    })
                    
                    if _G.GradientSpin then
                        objects.gradient.Rotation = (objects.gradient.Rotation + ((_G.GradientSpinSpeed or 0.1) * 0.2)) % 360
                    else
                        objects.gradient.Rotation = 90
                    end
                end
                
                -- Glow
                if objects.glow then
                    objects.glow.Visible = espLibrary.options.glowImage and show and self.options.boxFill
                    objects.glow.ImageColor3 = _G.glowcolor
                end
                
                -- Health Bar
                objects.healthBar.Visible = show and self.options.healthBars
                objects.healthBar.BackgroundColor3 = color or self.options.healthBarsColor
                objects.healthBar.BackgroundTransparency = 1 - self.options.healthBarsTransparency
                objects.healthBar.Size = UDim2.new(0, healthBarSize.X, 0, math.abs(healthBarSize.Y))
                objects.healthBar.Position = UDim2.new(0, healthBarPosition.X, 0, healthBarPosition.Y - math.abs(healthBarSize.Y))
                
                objects.healthBarOutline.Visible = show and self.options.healthBars
                objects.healthBarOutline.BackgroundTransparency = 1 - self.options.healthBarsTransparency
                objects.healthBarOutline.Size = UDim2.new(0, healthBarSize.X + 2, 0, size.Y + 2)
                objects.healthBarOutline.Position = UDim2.new(0, healthBarPosition.X - 1, 0, position.Y - 1)
                
                -- Tracer Line
                objects.line.Visible = show and self.options.tracers
                objects.line.BackgroundColor3 = color or self.options.tracerColor
                objects.line.BackgroundTransparency = 1 - self.options.tracerTransparency
                
                local origin = self.options.tracerOrigin
                local fromPos = 
                    origin == "Mouse" and userInputService:GetMouseLocation() or
                    origin == "Top" and vector2New(viewportSize.X * 0.5, 0) or
                    origin == "Bottom" and vector2New(viewportSize.X * 0.5, viewportSize.Y)
                
                local lineVec = torsoPosition - fromPos
                local lineLength = lineVec.Magnitude
                local lineAngle = math.deg(math.atan2(lineVec.Y, lineVec.X))
                
                objects.line.Size = UDim2.new(0, lineLength, 0, 1)
                objects.line.Position = UDim2.new(0, fromPos.X, 0, fromPos.Y)
                objects.line.Rotation = lineAngle
            else
                for _, object in next, objects do
                    if object and typeof(object) == "Instance" then
                        object.Visible = false
                    end
                end
            end
        end
        
        for player, highlight in next, self.chamsCache do
            local character, torso = self.getCharacter(player)
            
            if character and torso then
                local distance = (currentCamera.CFrame.Position - torso.Position).Magnitude
                local canShow = self.options.enabled and self.options.chams
                local team, teamColor = self.getTeam(player)
                local color = self.options.teamColor and teamColor or nil
                
                if self.options.fillColor ~= nil then
                    color = self.options.fillColor
                end
                
                if find(self.whitelist, player.Name) then
                    color = self.options.whitelistColor
                end
                
                if find(self.blacklist, player.Name) then
                    canShow = false
                end
                
                if self.options.limitDistance and distance > self.options.maxDistance then
                    canShow = false
                end
                
                if self.options.teamCheck and (team == self.getTeam(localPlayer)) then
                    canShow = false
                end
                
                highlight.Enabled = canShow
                highlight.DepthMode = self.options.visibleOnly and Enum.HighlightDepthMode.Occluded or Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Adornee = character
                highlight.FillColor = color or self.options.chamsFillColor
                highlight.FillTransparency = self.options.chamsFillTransparency
                highlight.OutlineColor = color or self.options.chamsOutlineColor
                highlight.OutlineTransparency = self.options.chamsOutlineTransparency
            end
        end
        
        for object, cache in next, self.objectCache do
            local partPosition = vector3New()
            
            if object:IsA("BasePart") then
                partPosition = object.Position
            elseif object:IsA("Model") then
                partPosition = self.getBoundingBox(object)
            end
            
            local distance = (currentCamera.CFrame.Position - partPosition).Magnitude
            local screenPosition, onScreen = worldToViewportPoint(partPosition)
            local canShow = cache.options.enabled and onScreen
            
            if self.options.limitDistance and distance > self.options.maxDistance then
                canShow = false
            end
            
            if self.options.visibleOnly and not self.visibleCheck(object, partPosition) then
                canShow = false
            end
            
            cache.text.Visible = canShow
            cache.text.Font = cache.options.font
            cache.text.TextSize = cache.options.fontSize
            cache.text.TextTransparency = 1 - cache.options.transparency
            cache.text.TextColor3 = cache.options.color
            cache.text.Text = cache.options.text
            cache.text.Size = UDim2.new(0, cache.text.TextBounds.X, 0, cache.text.TextBounds.Y)
            cache.text.Position = UDim2.new(0, round(screenPosition.X), 0, round(screenPosition.Y))
        end
    end)
end

return espLibrary
